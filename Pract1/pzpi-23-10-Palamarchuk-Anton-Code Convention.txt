МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
Кафедра «Програмна інженерія»






ЗВІТ
з практичної роботи
з дисципліни «Аналіз та рефакторінг коду»
на тему «Основні рекомендації написання коду для мови програмування С++»




Виконав:
ст. гр. ПЗПІ-23-10
Паламарчук А.А

Перевірив:
старший викл. Кафедри ПІ
Сокорчук І.П.



Харків 2025
      1 ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень101.10.20250.1Створено “Мету роботи”, “Хід роботи з усіма описами”, “Висновок”, “Використані джерела ”202.10.20250.1Створено “Додаток А” та заповнено “Додаток Б”310.10.20250.2Виправлено та додано “Історію змін”, “Завдання”, “Опис виконаної роботи”411.10.20250.2Додано “Додаток В” та виправлені відповідні частини у роботі


      2 ЗАВДАННЯ
      Мета роботи
      Метою моєї роботи є ознайомлення з основними принципами написання якісного та зрозумілого коду мовою програмування C++, а також формування практичних навичок їх застосування. Я прагну показати важливість використання правил структурування коду, дотримання єдиного стилю форматування, зрозумілого іменування змінних, функцій і класів, а також грамотного застосування коментарів і документації. Це допомагає уникати типових помилок, робити код більш читабельним і надійним, полегшувати його тестування та подальшу підтримку. Крім того, мета полягає у розвитку вміння застосовувати сучасні інструменти перевірки стилю й автоматизації, що є важливим елементом підготовки майбутніх фахівців у сфері програмної інженерії.


      3 ОПИС ВИКОНАНОЇ РОБОТИ
      Хід Роботи
      1. Структура коду
      У C++ дуже важливо правильно організовувати проєкт, оскільки він складається з багатьох файлів. Стандартна практика передбачає використання заголовкових файлів (.h або .hpp) для оголошення класів і функцій та окремих файлів реалізації (.cpp) для їх визначення (Див. додаток В.1). Такий поділ дозволяє підтримувати інкапсуляцію, чітко відокремлювати інтерфейс від реалізації, що робить код більш зрозумілим і модульним. Якщо ж змішувати все в одному файлі, код швидко перетворюється на хаотичну суміш, яку складно підтримувати й розвивати.
      Крім того, у C++ варто групувати класи за їхнім функціональним призначенням (наприклад, User, Database, Logger) (Див. додаток В.2). Це дає змогу легше розширювати систему, додаючи нові можливості без необхідності переписувати великі частини коду. Правильна структура проєкту не лише спрощує підключення потрібних модулів, але й робить тестування та розширення програми значно ефективнішими.
      2. Форматування коду
      Форматування — це перше, що кидається у вічі, коли відкриваєш файл з кодом. Чіткі відступи, вирівнювання та єдиний стиль розташування дужок одразу показують, де починається й закінчується блок коду, яка вкладеність у функціях чи умовах (Див. додаток В.3). У великих проєктах це суттєво економить час, адже код стає передбачуваним і зрозумілим для всієї команди. Хаотичне ж форматування створює безлад і змушує витрачати зайві зусилля на розуміння логіки.
      У C++ зазвичай роблять відступи в межах 4 пробілів або табуляцій — головне, щоб був єдиний підхід. Це допомагає легко бачити структуру та вкладеність. Також існує кілька популярних стилів розташування дужок, серед яких найчастіше використовуються K&R та Allman (Див. додаток В.4). Вибір конкретного стилю не настільки важливий, як його послідовне застосування, адже саме стабільність у форматуванні забезпечує зручність роботи з кодом.
      3. Іменування
      У програмуванні часто кажуть: «код читається набагато частіше, ніж пишеться». Саме тому правильний вибір імен для змінних, функцій і класів надзвичайно важливий. У C++ поширено використовувати такі конвенції: camelCase для змінних і функцій, PascalCase для класів та UPPER_CASE для констант (Див. додаток В.5). Це робить код більш зрозумілим, передбачуваним і зменшує ризик плутанини.
      Ім’я завжди має відображати призначення елемента (Див. додаток В.6). Наприклад, змінна userAge одразу пояснює свою роль, тоді як ua виглядає незрозумілою і вимагає додаткового аналізу. Варто уникати випадкових скорочень чи абревіатур без потреби, адже вони ускладнюють читання. Добре підібрані назви фактично стають короткою документацією до коду, що особливо допомагає новим розробникам швидше увійти в робочий процес.
      4. Коментарі
      Коментарі в коді слід використовувати розумно. Вони мають пояснювати не те, що робить код, а чому він це робить. Наприклад, якщо у функції використовується рекурсія, доцільно зазначити, чому було обрано саме такий підхід. Це допомагає іншим розробникам швидко зрозуміти логіку та архітектурні рішення (Див. додаток В.7).
Важливо уникати надмірних або зайвих коментарів, які лише дублюють код і створюють інформаційний шум. З іншого боку, повна відсутність пояснень може перетворити навіть добре написаний код на складну головоломку. Тому коментар має бути коротким, точним і роз’яснювати ті моменти, які без нього важко зрозуміти.
      5. Документування коду
      Документування у C++ найчастіше виконується за допомогою системи Doxygen, яка генерує документацію безпосередньо з коментарів у коді. Це особливо корисно у великих проєктах, де над різними модулями працюють кілька розробників. Добре оформлений коментар у стилі Doxygen одразу показує, які параметри приймає функція (@param), що вона повертає (@return) і яке її призначення (Див. додаток В.8). Така автоматично створена документація значно економить час і робить API зрозумілішим. 
      Відсутність документації ускладнює роботу команди: іншим доводиться витрачати багато зусиль, щоб розібратися в логіці функцій, а сам автор через кілька років може забути деталі реалізації. Документування — це інвестиція в майбутнє, яка забезпечує зрозумілість і підтримуваність коду навіть через 5–10 років.
      6. Конвенції стилю кодування для C++
      У командній роботі часто виникають суперечки щодо стилю написання коду: хтось ставить дужки в одному рядку, хтось на новому; хтось віддає перевагу пробілам, хтось табуляціям. Щоб уникнути таких дискусій і підтримувати єдиний стиль у всьому проєкті, у C++ часто використовують інструмент ClangFormat (Див. додаток В.9). Він автоматично форматувує код за заданими правилами, вирівнює відступи, розставляє дужки та дозволяє обрати готовий стиль, наприклад Google чи Mozilla.
      ClangFormat легко інтегрується у популярні IDE, наприклад Visual Studio, і дозволяє програмістам зосередитися на логіці програми, а не на дрібних питаннях стилю. Без таких інструментів у великій команді швидко накопичується хаос, що ускладнює читання коду й знижує продуктивність.
      7. Кодування на основі тестування (TDD)
      Test-Driven Development (TDD) — це підхід, коли спочатку створюються тести, а вже потім реалізація. Основні етапи TDD такі: написати тест очікуваної поведінки, реалізувати код, а потім виконати його рефакторинг. Важливо дотримуватися правила «один тест — одна перевірка», щоб кожна функція мала власний набір тестів.
      У C++ для цього найчастіше використовують бібліотеки Google Test (gtest) та Catch2 (Див. додаток В.10). Вони дозволяють автоматично перевіряти роботу функцій і класів, що робить внесення змін у код безпечнішим: якщо щось зламається, тести одразу це покажуть. TDD дисциплінує розробників, допомагає створювати продуманішу архітектуру й дає змогу швидко впевнитися в працездатності програми після змін або рефакторингу. Це особливо актуально у C++, де легко припуститися помилок із пам’яттю чи типами даних.
      8. Інструменти та автоматизація для підтримки якості коду
      Якість коду у C++ можна підтримувати за допомогою статичного аналізу. Для цього використовують інструменти, такі як SonarQube, Codacy або Cppcheck (Див. додаток В.11), які допомагають знаходити потенційні помилки, не завжди помітні під час компіляції. Вони виявляють витоки пам’яті, небезпечні конструкції, дублікати коду та інші проблеми, що можуть призвести до багів у продакшн-версії.
      Якщо перевірки інтегрувати в CI/CD, кожен новий коміт автоматично аналізується, що значно зменшує ризик появи помилок у робочому коді. Ігнорування таких інструментів може призвести до накопичення прихованих проблем, які проявляться вже у користувача. Автоматизація статичного аналізу робить розробку більш надійною і передбачуваною.
      9. Загальні приклади оформлення коду та їх аналіз
      Найкращий спосіб зрозуміти важливість правил оформлення — це подивитися на гарні та погані приклади коду. Добре оформлений код має зрозумілі імена змінних, чіткі відступи, компактні та логічно побудовані функції. Його можна читати як звичайний текст, і навіть нова людина у команді швидко зрозуміє, що відбувається. Погано оформлений код, навпаки, часто зібраний в один рядок, має незрозумілі позначення й відсутні коментарі. У такому випадку кожна дрібна зміна може стати ризиком. Для команди це означає втрату часу на пояснення, пошук помилок і відсутність задоволення від роботи. Чистота коду прямо впливає на швидкість вирішення задач і продуктивність команди. Гарно оформлений код надихає і спрощує командну роботу, тоді як хаотичний — демотивує і гальмує розвиток проекту.
Приклад хорошого оформлення коду (Див. додаток В.12)
Плюси написання такого коду:
1. Імена зрозумілі (Student, printInfo, group).
2. Є відступи й вирівнювання.
3. Код компактний, але читається легко.
4. Єдині правила для дужок та форматування.

Приклад поганого оформлення коду (Див. додаток В.12)
Мінуси написання такого коду:
1. Майже все в одному рядку → неможливо читати.
2. Клас s має нерозбірливу назву.
3. Змінні a, n — незрозумілі.
4. Відсутні відступи та коментарі.


      4 ВИСНОВКИ
      У процесі розробки програмного забезпечення мовою C++ правила оформлення коду відіграють ключову роль, адже саме вони визначають зрозумілість, підтримуваність та якість кінцевого продукту. Кожен аспект має своє значення, а разом вони формують цілісну систему, яка робить програму професійною та довговічною.
      Найперше важливо продумати структуру коду: правильна організація файлів і модулів дозволяє логічно поділити програму на частини, що значно полегшує масштабування та спільну роботу. У C++ без чіткого поділу великий проєкт швидко перетворюється на хаотичний набір файлів, тоді як грамотна архітектура забезпечує зрозумілість і порядок.
      Не менш важливим є форматування. Єдині відступи, вирівнювання та оптимальна довжина рядків роблять код читабельним і дозволяють уникати плутанини. Узгоджений стиль оформлення дужок і пробілів зменшує кількість помилок і спрощує аналіз програми.
      Суттєву роль відіграє система іменування. Лаконічні та зрозумілі назви змінних, функцій і класів роблять код самодокументованим і зрозумілим навіть для нових учасників команди. Якщо ж цього правила не дотримуватися, навіть прості програми стають важкими для сприйняття.
      Коментарі й документація доповнюють код поясненнями та описами, допомагаючи швидко розібратися в складних частинах і логіці. Коментарі мають пояснювати рішення, а не повторювати очевидне, а автоматизоване документування засобами на кшталт Doxygen створює повноцінну технічну базу знань для проєкту.
      Конвенції стилю кодування та інструменти автоматизації, такі як ClangFormat, допомагають підтримувати єдність у проєкті, усуваючи розбіжності у стилі й дозволяючи команді зосередитися на змісті коду. У свою чергу, методологія розробки через тестування (TDD) і використання інструментів статичного аналізу (Cppcheck, SonarQube) підвищують надійність і дозволяють швидко виявляти потенційні проблеми.
      Нарешті, приклади гарного й поганого оформлення доводять, наскільки серйозно правила впливають на зручність роботи. Добре структурований і оформлений код легко читати, змінювати й масштабувати, тоді як хаотичний стиль ускладнює навіть найпростіші завдання.
      Отже, правила оформлення коду в C++ охоплюють організацію структури, форматування, іменування, коментування, документування, дотримання стилю, тестування й автоматизацію перевірок. Вони взаємопов’язані та разом формують систему, яка забезпечує прозорість і зрозумілість коду, підвищує ефективність командної роботи та гарантує стабільний розвиток програмного продукту в майбутньому.
      


5 ВИКОРИСТАНІ ДЖЕРЕЛА
      1.  Stack Overflow. Структура коду, іменування конвенцій, коментарі. URL: https://stackoverflow.com/questions (Дата звернення: 01.10.2025)
      2.  Mozilla Firefox — C++ Coding Style. «Formatting code» та інші правила. URL: https://firefox-source-docs.mozilla.org/code-quality/coding-style/coding_style_cpp.html (Дата звернення: 01.10.2025)
      3.  Doxygen. Documenting the code: Special comment blocks. URL: https://www.doxygen.nl/manual/docblocks.html (Дата звернення: 01.10.2025)
      4.  Alex Ott. Test-driven development and unit testing with examples in C++. URL: https://alexott.net/en/cpp/CppTestingIntro.html (Дата звернення: 01.10.2025)
      5.  Cppcheck. A tool for static C/C++ code analysis. URL: https://cppcheck.sourceforge.io/ (Дата звернення: 01.10.2025)



ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/1fuXLSWL5LA
Хронологічний опис відеозапису:
0:00 – Вступ (Про що буде мова у презентації)
0:35 - Організація проєкту та файлів (Розширення файлів та поділ їх за функціоналом)
1:06 - Принцип логічного поділу на модулі та класи (Клас повинен відповідати за відповідні йому функції та дії)
1:33 - Відступи, вирівнювання та довжина рядків (Правтльне використання відступів для покращення вкладеності та читабельності)
1:57 - Стандарти для дужок та відступів (Стандарти відступів дужок K&R та Allman)
2:30 - Конвенції іменування (Використання camelCase, PascalCase та UPPER_CASE)
2:59 - Принципи вибору імен (Назви повинні відповідати сутті функціоналу)
3:25 - Коли та де використовувати коментарі (Як правильно писати коментарі, щоб не створити захаращування файлу)
4:00 - Використання Doxygen (Хороша практика документування коду)
4:27 - Інструменти для перевірки стилю (Інструмент який дозволяє використовувати один стиль для написання коду усім розробникам)
5:01 - Основи TDD (Важливо проводити тестування поведінки майбутнього коду перед його реалізацією)
5:35 - Використання статичного аналізу коду (Інструмент для перевірки код на помилки, щоб позбутися проблем на продакшені)
6:08 - Приклад хорошого оформлення коду
6:49 - Приклад поганого оформлення коду
7:23 – Висновок (Підсумування усіх названих рекомендацій)
7:49 - Список Джерел


ДОДАТОК Б
Слайди презентації


Рисунок Б.1 – Титульний лист


Рисунок Б.2 – Вступ
      

Рисунок Б.3 – Організація проєкту та файлів


Рисунок Б.4 – Принципи логічного поділу на модулі та класи


Рисунок Б.5 – Відступи, вирівнювання та довжина рядків


Рисунок Б.6 – Стандарти для дужок та відступів


Рисунок Б.7 – Конвенції іменування


Рисунок Б.8 – Принципи вибору імен


Рисунок Б.9 – Коли та де використовувати коментарі


Рисунок Б.10 – Використання Doxygen


Рисунок Б.11 – Інструменти для перевірки стилю


Рисунок Б.12 – Основи TDD


Рисунок Б.13 – Використання статичного аналізу коду


Рисунок Б.14 – Приклад хорошого оформлення коду


Рисунок Б.15 – Приклад поганого оформлення коду


Рисунок Б.16 – Висновок

Рисунок Б.17 – Список Джерел


ДОДАТОК В
Програмний код
В.1 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract1/pzpi-23-10-Palamarchuk-Anton-pract1/code-examples-code-conventions.cpp
 1
 2
 3
 4
 5
 6
 7
 8
 9
10// MathUtils.cpp
#ifndef MATHUTILS_H
#define MATHUTILS_H

class MathUtils {
public:
    static int add(int a, int b);
};
#endif
1
2
3
4
5
6// MathUtils.cpp
#include "MathUtils.h"

int MathUtils::add(int a, int b) {
return a + b;
}
В.2 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract1/pzpi-23-10-Palamarchuk-Anton-pract1/code-examples-code-conventions.cpp
1
2
3class Logger { 
    public: void log(const std::string& message); 
};
1
2
3
4
5
6
7class Database {
public:
    void connect() {
        std::cout << "Connecting to database..." << std::endl;
    }
};В.3 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract1/pzpi-23-10-Palamarchuk-Anton-pract1/code-examples-code-conventions.cpp
1
2
3
4
5
6
7// Приклад хорошого коду 
if (x > 0) {
    std::cout << "Positive\n";
}
else {
    std::cout << "Non-positive\n";
}
1
2
3
4// Приклад поганого коду 
if(x>0){
std::cout << "Positive\n"; 
}else{ std::cout << "Non-positive\n"; }

В.4 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract1/pzpi-23-10-Palamarchuk-Anton-pract1/code-examples-code-conventions.cpp
1
2
3
4//K&R
if (x > 0) {
    std::cout << "Positive\n";
}
1
2
3
4
5//Allman
if (x > 0)
{
    std::cout << "Positive\n";
}
В.5 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract1/pzpi-23-10-Palamarchuk-Anton-pract1/code-examples-code-conventions.cpp
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11//PascalCase 
class CarEngine {
public:
    void startEngine();
private:
    //camelCase
    int horsepower;
    //UPPER_CASE
    static const int MAX_RPM = 7000;
};
В.6 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract1/pzpi-23-10-Palamarchuk-Anton-pract1/code-examples-code-conventions.cpp
1
2
3int userAge; // добре 

int ua;      // погано

В.7 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract1/pzpi-23-10-Palamarchuk-Anton-pract1/code-examples-code-conventions.cpp
1
2
3
4
5
6//Приклад хорошого коду
// Використовуємо рекурсію, бо потрібне дерево рішень
int factorial(int n) {
   if (n <= 1) return 1;
   return n * factorial(n - 1);
}
1
2
3
4
5
6
7
8
9//Приклад поганого коду
// Оголошуємо функцію факторіала 
int factorial(int n) {
    // Якщо п менше або дорівнює 1, повертаємо 1 
    if (n <= 1) return 1;
    // Повертаємо п помножене на факторіал (п - 1)
    return n * factorial(n - 1); // множимо п на попереднє
}В.8 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract1/pzpi-23-10-Palamarchuk-Anton-pract1/code-examples-code-conventions.cpp
1
2
3
4
5
6
7/**
* @brief Обчислює суму двох чисел
* @param a перше число
* @param b друге число
* @return сума чисел
*/
int add(int a, int b);
В.9 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract1/pzpi-23-10-Palamarchuk-Anton-pract1/code-examples-code-conventions.cpp
1
2// Приклад використання ClangFormat з стилем Google 
clang-format -style=Google -i main.cpp
В.10 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract1/pzpi-23-10-Palamarchuk-Anton-pract1/code-examples-code-conventions.cpp
1
2
3
4
5
6
7// Використання Google Test
#include <gtest/gtest.h>
#include "MathUtils.h"

TEST(MathUtilsTest, AddPositiveNumbers) {
   EXPECT_EQ(MathUtils::add(2, 3), 5);
}
 1
 2
 3
 4
 5
 6
 7
 8
 9
10// Використання Catch2
#define CATCH_CONFIG_MAIN
#include "catch.hpp"

int add(int a, int b) { return a + b; }

TEST_CASE("Addition works correctly") {
   REQUIRE(add(2, 3) == 5);
   REQUIRE(add(-1, 1) == 0);
}
В.11 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract1/pzpi-23-10-Palamarchuk-Anton-pract1/code-examples-code-conventions.cpp
1
2//Підключення Cppcheck
cppcheck --enable-all src/

В.12 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract1/pzpi-23-10-Palamarchuk-Anton-pract1/code-examples-code-conventions.cpp
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30#include <iostream>
#include <vector>

class Student {
public:
    Student(const std::string& name, int age)
        : name(name), age(age) {
    }

    void printInfo() const {
        std::cout << "Name: " << name
            << ", Age: " << age << std::endl;
    }

private:
    std::string name;
    int age;
};

int main() {
    std::vector<Student> group = {
        {"Anna", 20}, {"Petro", 22}, {"Olena", 21}
    };

    for (const auto& student : group) {
        student.printInfo();
    }

    return 0;
}
1
2
3
4
5
6#include<iostream>
class s { public:int a; std::string n; s(std::string N, int A)
{ n = N; a = A; }void p() { std::cout << n << ":" << a; } }; int main() { s 
4 x("A", 20); x.p(); }
0

