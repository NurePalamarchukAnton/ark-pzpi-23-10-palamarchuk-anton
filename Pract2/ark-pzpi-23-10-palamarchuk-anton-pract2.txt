МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
Кафедра «Програмна інженерія»






ЗВІТ
з практичної роботи
з дисципліни «Аналіз та рефакторінг коду»
на тему «Методи рефакторингу такі як: Методи переіменування, Метод заміни магічного числа символьною константою та Метод переміщення для мови програмування С++



Виконав:
ст. гр. ПЗПІ-23-10
Паламарчук А.А

Перевірив:
старший викл. Кафедри ПІ
Сокорчук І.П.



Харків 2025
      1 ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень101.11.20250.1Створено “Мету роботи”, “Хід роботи з усіма описами”, “Висновок”, “Використані джерела ”202.11.20250.1Створено “Додаток А” та заповнено “Додаток Б”38.11.20250.2Виправлено та додано “Історію змін”, “Завдання”, “Опис виконаної роботи”49.11.20250.2Додано “Додаток В” та виправлені відповідні частини у роботі


      2 ЗАВДАННЯ
      Мета роботи
      Метою роботи є закріплення практичних навичок застосування методів рефакторингу коду для підвищення його якості, читабельності та зручності підтримки. У процесі дослідження використано три основні методи з книги Роберта Мартіна «Чистий код»: перейменування, заміна магічного числа символьною константою та переміщення методу. Застосування цих технік дозволяє усунути дублювання коду, покращити його структуру та зробити програму більш зрозумілою, гнучкою й зручною для подальшого розширення.

      3 ОПИС ВИКОНАНОЇ РОБОТИ
      Хід Роботи
1. Проблеми іменувань у коді та її вирішення
1.1 Опис проблеми іменувань
      У початковій версії коду спостерігається використання неінформативних або надто коротких назв методів і змінних, таких як multiplyWithOperations(), sumElements(), ops1, ops2, M3 (Див. додаток В.3). Подібні назви не передають реального змісту та призначення елементів програми. Це створює труднощі під час читання, тестування та подальшої підтримки коду, особливо якщо проект розвивається або до нього долучаються інші розробники.
      Невдале іменування ускладнює розуміння логіки програми без детального аналізу її внутрішньої структури, що збільшує час на налагодження та підвищує ризик помилок. Код перестає бути самодокументованим — тобто таким, який пояснює себе без потреби у коментарях.
      Згідно з принципами, викладеними Робертом Мартіном у книзі «Чистий код», правильно підібрані назви змінних, методів і класів мають чітко описувати їхню роль у програмі. Код повинен “читатися як звичайний текст”, що полегшує його сприйняття навіть без додаткових пояснень.
      Рефакторинг через перейменування дозволяє зробити програму більш логічною, зрозумілою та узгодженою. Інформативні назви допомагають швидко зорієнтуватися у структурі коду, зменшують кількість можливих непорозумінь між розробниками, покращують якість супроводу й полегшують подальший розвиток проєкту без ризику порушити функціональність.
1.2 Вирішення проблеми за допомогою методу переіменування
      Після рефакторингу код став значно зрозумілішим і зручнішим у роботі завдяки введенню нових змістовних назв, таких як operationCount та resultMatrix (Див. додаток В.4). Це зробило код самодокументованим — кожен елемент тепер чітко відображає свою роль і призначення, що полегшує розуміння логіки програми без додаткових коментарів. Такий підхід відповідає принципам “Clean Code” Роберта Мартіна, де зрозумілі назви й чітка структура є основою якісного програмного забезпечення. З технічної точки зору, рефакторинг зменшив когнітивне навантаження під час читання, спростив відлагодження та розширення функціоналу, підвищив підтримуваність, узгодженість і загальну архітектурну якість програми без зміни її функціональності.
2. Проблема “магічних чисел” у коді та її вирішення
2.1 Опис проблеми “магічних чисел”
      У наведеному коді використовується вираз __cpuid(cpuInfo, 1);, де число 1 є так званим магічним числом — значенням без пояснення його змісту (Див. додаток В.1). Такий підхід знижує зрозумілість і ускладнює подальше супроводження коду, адже невідомо, що саме означає це число: ідентифікатор запиту, тип команди чи параметр. Це суперечить принципам “Clean Code” Роберта Мартіна, згідно з якими кожен елемент коду має бути самодокументованим.
      Щоб уникнути подібної неоднозначності, застосовується метод «Заміна магічного числа символьною константою». Його мета — надати числовим значенням зрозумілі назви, що пояснюють їхнє призначення. Це підвищує читабельність, спрощує розуміння логіки програми та зменшує ризик помилок під час редагування. У результаті код стає більш структурованим, підтримуваним і відповідає сучасним стандартам розробки, де пріоритетом є ясність, надійність та зручність у подальшій роботі.
2.2 Вирішення проблеми за допомогою методу заміни магічного числа символьною константою
      Після рефакторингу в код було введено символічну константу CPU_FEATURE_ID, яка замінила неінформативне магічне число у виклику функції __cpuid() (Див. додаток В.2). Це зробило код більш зрозумілим, адже тепер значення параметра пояснює свій зміст без додаткових коментарів. Розробник одразу бачить, що CPU_FEATURE_ID позначає ідентифікатор типу запиту, що значно підвищує читабельність і спрощує логіку програми. Такий підхід покращує підтримуваність і розширюваність — у разі зміни значення достатньо відредагувати лише одну константу, що мінімізує ризик помилок.
      З технічної точки зору, заміна магічних чисел символьними константами усуває неоднозначність і зменшує когнітивне навантаження при аналізі коду. Код стає самодокументованим, узгодженим зі стандартами “Clean Code” Роберта Мартіна, який наголошує на важливості зрозумілих імен та відсутності прихованої логіки. Крім того, це підвищує гнучкість програми — тепер легко додати інші константи для нових типів процесорних запитів, не змінюючи основну структуру коду. Таким чином, рефакторинг підвищив якість, масштабованість та професійний рівень реалізації.
3. Проблема розсташування інформації у коді та її вирішення
3.1 Опис проблеми розсташування інформації у коді
      У наведеному коді метод getCustomerDiscount() спочатку був розміщений у класі Order, хоча фактично він оперує даними, що належать іншому класу — Customer, зокрема полем loyaltyPoints (Див. додаток В.5). Така реалізація порушує основні принципи об’єктно-орієнтованого програмування, зокрема інкапсуляцію та принцип єдиної відповідальності (SRP). Це означає, що клас починає виконувати не лише власні завдання (обробку замовлень), а й логіку, пов’язану з іншим об’єктом — клієнтом. У результаті зростає зв’язність між класами, а зміна логіки розрахунку знижок призведе до необхідності змін у класі Order, навіть якщо його основне призначення не змінюється.
      Така залежність робить систему менш гнучкою та ускладнює підтримку: будь-яка зміна структури класу Customer може спричинити помилки у Order. Крім того, це знижує зрозумілість коду — інший розробник, переглядаючи клас замовлень, може не одразу зрозуміти, чому в ньому реалізована логіка, пов’язана із клієнтами. Це суперечить рекомендаціям з книги Роберта Мартіна “Чистий код”, де наголошується, що кожен клас має мати чітко визначену відповідальність, а логіка має бути розміщена там, де вона природно належить.
      Застосування методу рефакторингу «Переміщення методу» (Move Method) є оптимальним рішенням для цієї ситуації. Він дозволяє перенести функціональність у клас, який містить необхідні дані, забезпечуючи логічну узгодженість і зменшуючи взаємозалежність між компонентами. Перемістивши метод getCustomerDiscount() до класу Customer, ми робимо код більш модульним, прозорим і стійким до змін. У результаті кожен клас відповідає лише за свої дані й поведінку, що покращує підтримуваність, розширюваність і тестування програми. Такий підхід також сприяє кращій структуризації коду, робить його ближчим до принципів SOLID і загальноприйнятих практик професійного програмування.
3.2 Вирішення проблеми за допомогою методу переміщення
      Після застосування рефакторингу методом «Переміщення методу» код став значно більш структурованим і узгодженим. Ми перенесли метод, що відповідає за розрахунок знижки, безпосередньо до класу Customer, де він логічно належить (Див. додаток В.6). Завдяки цьому вдалося досягти кращої інкапсуляції, адже тепер логіка роботи зі знижками зосереджена в об’єкті, який містить усі необхідні дані для її обчислення. Клас Order більше не повинен знати, як саме розраховується знижка, — він просто викликає готовий метод клієнта, що значно зменшує зв’язність між класами та робить систему більш незалежною.
      Такий підхід підвищує читабельність і зрозумілість коду: кожен клас має лише одну відповідальність, що повністю відповідає принципу Single Responsibility Principle (SRP) із набору SOLID. Тепер розробнику легко зрозуміти, де шукати логіку, пов’язану із клієнтом або замовленням, а майбутні зміни в правилах нарахування знижок не потребуватимуть втручання в інші частини програми.
      З технічного боку, це підвищило гнучкість і масштабованість системи — при додаванні нових типів клієнтів або зміні логіки знижок достатньо змінити лише клас Customer. Крім того, такий поділ спрощує модульне тестування, оскільки кожен клас можна перевіряти окремо. У результаті код став більш модульним, підтримуваним і самодокументованим, що повністю узгоджується з принципами “Clean Code” Роберта Мартіна, згідно з якими гарний код має бути зрозумілим, узгодженим і легким для змін без ризику порушити інші частини системи.



      4 ВИСНОВКИ
      У ході цієї роботи було застосовано три ключові методи рефакторингу — перейменування, заміна магічного числа символічною константою та переміщення методу, — кожен із яких зробив вагомий внесок у покращення якості коду відповідно до принципів “Clean Code” Роберта Мартіна.
      Метод перейменування допоміг зробити код значно більш зрозумілим і самодокументованим. Завдяки чітким і змістовним назвам змінних та методів, код тепер легко читати без додаткових коментарів, що особливо важливо при роботі в команді. Це зменшило когнітивне навантаження на розробників і спростило процес супроводу та тестування програмного забезпечення. Такий підхід відповідає принципу “код має читатися як добре написаний текст” — одній із ключових ідей чистого коду.
      Заміна магічного числа символічною константою усунула приховані та неочевидні значення в коді, що могли призводити до помилок або плутанини при зміні логіки. Використання констант підвищило прозорість та однозначність коду, зробило його гнучкішим і простішим у підтримці. Тепер будь-яка зміна параметрів відбувається централізовано, без необхідності редагувати численні ділянки коду, що значно зменшує ризик виникнення помилок і підвищує стабільність системи.
      Метод переміщення дозволив покращити архітектуру програми за рахунок розміщення методів у тих класах, до яких вони логічно належать. Це зменшило залежності між компонентами, посилило інкапсуляцію та реалізувало принцип єдиної відповідальності (SRP). У результаті кожен клас відповідає лише за власну частину логіки, що сприяє модульності, повторному використанню коду та простоті тестування.
      Загалом, проведений рефакторинг зробив програму більш структурованою, зрозумілою та підтримуваною. Код став чистішим, узгодженішим і ближчим до професійних стандартів програмування. Зменшено дублювання, покращено логічну організацію компонентів і забезпечено гнучкість для майбутнього розширення системи. Усі три застосовані методи продемонстрували, як навіть невеликі покращення можуть суттєво підвищити якість програмного продукту, його надійність і довговічність.
      


5 ВИКОРИСТАНІ ДЖЕРЕЛА
      1.  Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. – Київ: ФАБУЛА, 2019. – 416 с.
      2.  Fowler M. Refactoring: Improving the Design of Existing Code. – Boston: Addison-Wesley, 2018. – 512 p.
      3.  Meyers S. Effective C++: 55 Specific Ways to Improve Your Programs and Designs. – Boston: Addison-Wesley, 2005. – 320 p.
      4.  Паламарчук А. Лабораторні роботи з предмету паралельне програмування. – власна підготовка, 2025.


ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/tvmRpdIvb_0
Хронологічний опис відеозапису:
0:00 - Вступ
0:43 - Проблема іменувань у коді
1:23 - Код до і після рефакторингу за методом переіменування
1:56 - Пояснення покращень після рефакторингу за методом переіменування
2:41 - Проблема магічних чисел у коді
3:15 - Код до і після рефакторингу за методом заміни магічного числа символьною константою
3:36 - Пояснення покращень після рефакторингу за методом заміни магічного числа символьною константою
4:14 - Проблема розташувань методів та класів у коді
4:56 - Код до і після рефакторингу за методом переміщення
5:18 - Пояснення покращень після рефакторингу за методом переміщення
6:00 - Висновок
6:47 - Список Джерел


ДОДАТОК Б
Слайди презентації


Рисунок Б.1 – Титульний лист


Рисунок Б.2 – Вступ
      

Рисунок Б.3 – Проблема іменувань у коді


Рисунок Б.4 – Код до і після застосування методу переіменуванню


Рисунок Б.5 – Переваги методу переіменування


Рисунок Б.6 – Проблема “магічних чисел” у коді

Рисунок Б.7 – Код до і після застосування методу заміни магічного числа константою


Рисунок Б.8 – Переваги методу “Заміна магічного числа символьною константою”


Рисунок Б.9 – Проблема розсташування інформації у коді


Рисунок Б.10 – Код до і після застосування методу переміщення

Рисунок Б.11 – Переваги методу переміщення


Рисунок Б.12 – Висновок


Рисунок Б.13 – Список Джерел

ДОДАТОК В
Програмний код
В.1 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract2/ark-pzpi-23-10-palamarchuk-anton-pract1/code-examples-refactoring-methods.cpp
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29#include <iostream>
#include <bitset>
#include <intrin.h>

class CPUFeatureDetector {
public:
    void printCPUFeatures() {
        int cpuInfo[4];
        __cpuid(cpuInfo, 1); // Магічне число

        std::bitset<32> ecx(cpuInfo[2]);
        std::bitset<32> edx(cpuInfo[3]);

        std::cout << "SSE: " << edx[25] << std::endl;
        std::cout << "SSE2: " << edx[26] << std::endl;
        std::cout << "SSE3: " << ecx[0] << std::endl;
        std::cout << "AVX: " << ecx[28] << std::endl;
    }
};

int main() {
    CPUFeatureDetector detector;
    detector.printCPUFeatures();
    return 0;
}
В.2 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract2/ark-pzpi-23-10-palamarchuk-anton-pract1/code-examples-refactoring-methods.cpp

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31#include <iostream>
#include <bitset>
#include <intrin.h>

class CPUFeatureDetector {
public:
    static const int CPU_FEATURE_ID = 1;

    void printCPUFeatures() {
        int cpuInfo[4];
        __cpuid(cpuInfo, CPU_FEATURE_ID);

        std::bitset<32> ecx(cpuInfo[2]);
        std::bitset<32> edx(cpuInfo[3]);

        std::cout << "SSE: " << edx[25] << std::endl;
        std::cout << "SSE2: " << edx[26] << std::endl;
        std::cout << "SSE3: " << ecx[0] << std::endl;
        std::cout << "AVX: " << ecx[28] << std::endl;
    }
};

int main() {
    CPUFeatureDetector detector;
    detector.printCPUFeatures();
    return 0;
}
В.3 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract2/ark-pzpi-23-10-palamarchuk-anton-pract1/code-examples-refactoring-methods.cpp
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11long long ops2;
Matrix M3 = M1.multiplyWithOperations(M2, ops2);
clock_t end2 = clock();

cout << "\n=== З об'єктами ===\n";
cout << "Sum of elements: " << M3.sumElements() << endl;
cout << "Time: " << double(end2 - start2) / CLOCKS_PER_SEC << " s\n";
cout << "Estimated O(n^3) operations: " << ops2 << endl;
В.4 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract2/ark-pzpi-23-10-palamarchuk-anton-pract1/code-examples-refactoring-methods.cpp
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12long long operationCount;
Matrix resultMatrix = M1.multiplyAndCountOperations(M2, operationCount);
clock_t endTime = clock();

cout << "\n=== Object-Oriented Version ===\n";
cout << "Sum of elements: " << resultMatrix.getTotalSum() << endl;
cout << "Execution time: " << double(endTime - start2) / CLOCKS_PER_SEC << " seconds\n";
cout << "Estimated O(n^3) operations: " << operationCount << endl;
В.5 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract2/ark-pzpi-23-10-palamarchuk-anton-pract1/code-examples-refactoring-methods.cpp
1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35class Order {
private:
    double amount;
    Customer* customer;
public:
    Order(double a, Customer* c) : amount(a), customer(c) {}

    double getCustomerDiscount() {
        if (customer->getLoyaltyPoints() > 1000) {
            return 0.1;
        }
        else {
            return 0.05;
        }
    }

    double calculateTotalPrice() {
        return amount - amount * getCustomerDiscount();
    }
};

class Customer {
private:
    std::string name;
    int loyaltyPoints;
public:
    Customer(std::string n, int points) : name(n), loyaltyPoints(points) {}

    int getLoyaltyPoints() {
        return loyaltyPoints;
    }
};
В.6 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NurePalamarchukAnton/ark-pzpi-23-10-palamarchuk-anton/blob/main/Pract2/ark-pzpi-23-10-palamarchuk-anton-pract1/code-examples-refactoring-methods.cpp
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35class Customer {
private:
    std::string name;
    int loyaltyPoints;
public:
    Customer(std::string n, int points) : name(n), loyaltyPoints(points) {}

    int getLoyaltyPoints() {
        return loyaltyPoints;
    }

    double getDiscount() {
        if (loyaltyPoints > 1000) {
            return 0.1;
        }
        else {
            return 0.05;
        }
    }
};

class Order {
private:
    double amount;
    Customer* customer;
public:
    Order(double a, Customer* c) : amount(a), customer(c) {}

    double calculateTotalPrice() {
        return amount - amount * customer->getDiscount();
    }
};



0

